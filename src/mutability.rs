use ast::Ast;
use lang_result::LangError;
use s_expression::SExpression;
use std::collections::HashMap;

/// Shorthand for a HashMap that maps Strings to Mutability enums
pub type MutabilityMap = HashMap<String, Mutability>;

// The Void indicates that check was successful without any errors, the MutabilityError will descibe the error that was encountered while checking mutability.
pub type MutabilityResult = Result<(), MutabilityError>;

/// Mutability values variables can have.
#[derive(Debug, Clone)]
pub enum Mutability {
    Mutable,
    Immutable
}


/// Types of errors that can be generated by the mutability checker.
#[derive(Debug, Clone)]
pub enum MutabilityError {
    CanNotAssignToConstVariable,
    CanNotRedeclareConst,
    VariableDoesNotExist,
    IsNotAVariable,
    CanNotRedeclareFunction,
    CanNotRedeclareStruct
}


impl Ast {

    /// Checks assignments and declarations to prevent duplicate use of variables of different mutability states.
    /// This will prevent declaring a function and then reassigning it to be a variable
    /// or preventing altering a constant value.
    ///
    /// This has the stipulation that for every expression list it encounters, the function will assume that
    /// it should create a new scope. This leads to the requirement that REPL input
    /// (which is known to always be a list with a single element)
    /// needs to be hoisted out of its list, as each new input would otherwise be given a new scope,
    /// breaking the mutability checker.
    pub fn check_mutability_semantics(&self, map: &mut MutabilityMap) -> Result<(), MutabilityError> {
        match *self {
            Ast::ExpressionList( ref expressions) => {
                let mut cloned_map = map.clone(); // Clone the map, so you can use different mutability rules in sibling scopes.
                for expression in expressions {
                    let _ = expression.check_mutability_semantics(&mut cloned_map)?;
                }
                return Ok(())
            }
            Ast::SExpr(ref s_expression) => {
                match *s_expression {
                    SExpression::Assignment{ref identifier, ref ast} => { // a := 5
                        let resolved_id: String = match **identifier {
                            Ast::ValueIdentifier(ref id) => id.clone(),
                            _ => return Err(MutabilityError::IsNotAVariable) // Error, AST malformed, couldn't resolve the id
                        };
                        if let Some(mutability) = map.get(&resolved_id) {
                            match *mutability {
                                Mutability::Mutable => Ok(()),
                                Mutability::Immutable => Err(MutabilityError::CanNotAssignToConstVariable) // tried to assign a value to immutable value
                            }
                        } else {
                            Err(MutabilityError::VariableDoesNotExist) // variable doesn't exist yet
                        }
                    }
                    SExpression::ConstDeclaration {ref identifier, ref ast} => { // const a := 5
                        let resolved_id: String = match **identifier {
                            Ast::ValueIdentifier(ref id) => id.clone(),
                            _ => return Err(MutabilityError::IsNotAVariable) // Error, AST malformed, couldn't resolve the id
                        };
                        if let Some(_) = map.get(&resolved_id) {
                            Err(MutabilityError::CanNotRedeclareConst) // tried to assign a value to immutable value
                        } else {
                            map.insert(resolved_id, Mutability::Immutable); // prevent reassignment of the fn
                            Ok(())
                        }
                    },
                    SExpression::VariableDeclaration { ref identifier, ref ast } => {
                        // let a := 5
                        let resolved_id: String = match **identifier {
                            Ast::ValueIdentifier(ref id) => id.clone(),
                            _ => return Err(MutabilityError::IsNotAVariable) // Error, AST malformed, couldn't resolve the id
                        };
                        {
                            if let Some(mutability) = map.get(&resolved_id) {
                                match *mutability {
                                    Mutability::Mutable => return Ok(()), // You are allowed to reassign other let variables, although there isn't really a reason to.
                                    Mutability::Immutable => return Err(MutabilityError::CanNotRedeclareConst) // tried to assign a value to immutable value
                                }
                            }
                        }
                        map.insert(resolved_id, Mutability::Mutable); // prevent reassignment of the fn
                        Ok(())
                    }
                    SExpression::CreateFunction { ref identifier, ref function_datatype } => {
                        let resolved_id: String = match **identifier {
                            Ast::ValueIdentifier(ref id) => id.clone(),
                            _ => return Err(MutabilityError::IsNotAVariable) // Error, AST malformed, couldn't resolve the id
                        };
                        if let Some(_) = map.get(&resolved_id) {
                            Err(MutabilityError::CanNotRedeclareFunction) // can't reassign functions
                        } else {
                            map.insert(resolved_id, Mutability::Immutable); // prevent reassignment of the fn
                            Ok(())
                        }
                    },
                    SExpression::StructDeclaration { ref identifier, ref struct_type_info} => {
                        let resolved_id: String = match **identifier {
                            Ast::ValueIdentifier(ref id) => id.clone(),
                            _ => return Err(MutabilityError::IsNotAVariable) // Error, AST malformed, couldn't resolve the id
                        };
                        if let Some(_) = map.get(&resolved_id) {
                            Err(MutabilityError::CanNotRedeclareStruct) // can't reassign struct type
                        } else {
                            map.insert(resolved_id, Mutability::Immutable); // prevent reassignment of the struct
                            Ok(())
                        }
                    }

                    _ => {
                        Ok(()) // if the expression doesn't add anything to the variable store, we don't care about it.
                    }
                }
            }
            _ => Ok(())
        }
    }
}